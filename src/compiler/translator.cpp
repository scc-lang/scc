module;

#include <cassert>
#include <memory>
#include <ostream>

export module scc.compiler:translator;
import :ast_binary_expression;
import :ast_conditional_statement;
import :ast_expression_statement;
import :ast_function_call_expression;
import :ast_identifier_expression;
import :ast_scope;
import :ast_statement;
import :ast_string_literal_expression;
import :ast_variable_declaration;
import :ast_visitor;
import :printer;

namespace scc::compiler {

export struct Translator final : AstVisitor {
    Translator(std::shared_ptr<std::ostream> out)
        : m_printer { std::move(out) }
    {
    }

    void VisitAstBinaryExpression(const AstBinaryExpression& binaryExpression) override
    {
    }

    void VisitAstBreakStatement(const AstBreakStatement& breakStatement) override
    {
    }

    void VisitAstConditionalStatement(const AstConditionalStatement& conditionalStatement) override
    {
    }

    void VisitAstExpressionStatement(const AstExpressionStatement& expressionStatement) override
    {
        assert(expressionStatement.expression);
        expressionStatement.expression->Visit(*this);
        m_printer.Println(";");
    }

    void VisitAstFunctionCallExpression(const AstFunctionCallExpression& functionCallExpression) override
    {
        assert(functionCallExpression.funcExpression);
        functionCallExpression.funcExpression->Visit(*this);

        m_printer.Print("(");
        if (!functionCallExpression.argsExpression.empty()) {
            auto it = functionCallExpression.argsExpression.begin();
            assert(*it);
            (*it)->Visit(*this);
            while (++it != functionCallExpression.argsExpression.end()) {
                m_printer.Print(", ");
                (*it)->Visit(*this);
            }
        }
        m_printer.Print(")");
    }

    void VisitAstIdentifierExpression(const AstIdentifierExpression& identifierExpression) override
    {
        if (identifierExpression.fullName.starts_with("std::")) {
            m_printer.Print("scc::{}", identifierExpression.fullName);
        } else {
            m_printer.Print(identifierExpression.fullName);
        }
    }

    void VisitAstIntegerLiteralExpression(const AstIntegerLiteralExpression& integerLiteralExpression) override
    {
    }

    void VisitAstLoopStatement(const AstLoopStatement& forStatement) override
    {
    }

    void VisitAstScope(const AstScope& scope) override
    {
        if (!scope.parentScope) {
            // Output declare for global scope.
            m_printer.Println("// scc autogenerated file.");
            m_printer.Println();
            m_printer.Println("import scc.std;");
            m_printer.Println();
            m_printer.Println("int main()");
        }

        m_printer.Println("{{");
        m_printer.PushIndent();
        for (const auto& statement : scope.statements) {
            statement->Visit(*this);
        }

        if (!scope.parentScope) {
            m_printer.Println("return 0;");
        }
        m_printer.PopIndent();
        m_printer.Println("}}");
    }

    void VisitAstStringLiteralExpression(const AstStringLiteralExpression& stringLiteralExpression) override
    {
        m_printer.Print("\"");
        for (const auto ch : stringLiteralExpression.value) {
            if (std::isprint(ch)) {
                m_printer.Print("{}", ch);
            } else {
                m_printer.Print("\\{:#03o}", ch);
            }
        }
        m_printer.Print("\"");
    }

    void VisitAstVariableDeclaration(const AstVariableDeclaration& variableDeclaration) override
    {
    }

    void VisitAstVariableDefinitionStatement(const AstVariableDefinitionStatement& variableDefinitionStatemet) override
    {
    }

private:
    Printer m_printer;
};

}